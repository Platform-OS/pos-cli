import { I as writable, S as SvelteComponent, i as init, s as safe_not_equal, e as element, t as text, b as space, c as claim_element, d as children, f as claim_text, g as detach, h as claim_space, j as attr, k as insert, a as append, q as set_data, n as noop, U as createEventDispatcher, p as listen, K as prevent_default, z as transition_in, D as create_component, E as claim_component, F as mount_component, X as add_flush_callback, A as transition_out, H as destroy_component, v as group_outros, y as check_outros, Y as add_render_callback, Z as create_in_transition, r as create_out_transition, Q as destroy_each, L as run_all, J as empty, M as binding_callbacks, _ as bind, $ as select_option, a0 as select_value, l as component_subscribe, N as get_store_value, a1 as toggle_class, a2 as create_bidirectional_transition, w as update_keyed_each, R as onMount, x as outro_and_destroy_block, a3 as params } from './main2.js';
import { f as format } from './index4.js';
import { a as api, f as filtersStore, p as pageStore } from './api.js';
import './store.js';

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => `overflow: hidden;` +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}

function getTime(datetime) {
  const dt = new Date(datetime);
  return format(dt, "dd MMM yyyy, HH:mm:ss");
}

const createStore = () => {
  const { subscribe, set, update } = writable([]);
  return {
    subscribe,
    set,
    update,
    addModel: (model) => {
      return update((models) => [...models, model]);
    },
    refreshModels: (schemaId, page = 1) => {
      return Promise.all([
        api.getModels({ schemaId, page }),
        api.getModels({ schemaId, deleted: true, page })
      ]).then((results) => {
        set([...results[0], ...results[1]]);
      });
    }
  };
};
var modelsStore = createStore();

/* src/_components/InputField.svelte generated by Svelte v3.24.1 */

function create_else_block$3(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", {
				class: true,
				type: true,
				value: true,
				placeholder: true,
				name: true,
				id: true
			});

			this.h();
		},
		h() {
			attr(input, "class", "w-full mr-2 form-input");
			attr(input, "type", "text");
			input.value = input_value_value = /*value*/ ctx[2] ? JSON.stringify(/*value*/ ctx[2]) : "";
			attr(input, "placeholder", /*attribute_type*/ ctx[0]);
			attr(input, "name", /*name*/ ctx[1]);
			attr(input, "id", "attr_type");
		},
		m(target, anchor) {
			insert(target, input, anchor);

			if (!mounted) {
				dispose = listen(input, "input", /*propagateUpdate*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 4 && input_value_value !== (input_value_value = /*value*/ ctx[2] ? JSON.stringify(/*value*/ ctx[2]) : "") && input.value !== input_value_value) {
				input.value = input_value_value;
			}

			if (dirty & /*attribute_type*/ 1) {
				attr(input, "placeholder", /*attribute_type*/ ctx[0]);
			}

			if (dirty & /*name*/ 2) {
				attr(input, "name", /*name*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			dispose();
		}
	};
}

// (30:2) {#if attribute_type === 'text' || attribute_type === 'upload' || attribute_type === 'array'}
function create_if_block$3(ctx) {
	let textarea;
	let textarea_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			textarea = element("textarea");
			this.h();
		},
		l(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", {
				class: true,
				rows: true,
				value: true,
				placeholder: true,
				name: true,
				id: true
			});

			children(textarea).forEach(detach);
			this.h();
		},
		h() {
			attr(textarea, "class", "w-full mr-2 form-input");
			attr(textarea, "rows", "3");
			textarea.value = textarea_value_value = JSON.stringify(/*value*/ ctx[2], null, 2);
			attr(textarea, "placeholder", /*attribute_type*/ ctx[0]);
			attr(textarea, "name", /*name*/ ctx[1]);
			attr(textarea, "id", "attr_type");
		},
		m(target, anchor) {
			insert(target, textarea, anchor);

			if (!mounted) {
				dispose = listen(textarea, "input", /*propagateUpdate*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 4 && textarea_value_value !== (textarea_value_value = JSON.stringify(/*value*/ ctx[2], null, 2))) {
				textarea.value = textarea_value_value;
			}

			if (dirty & /*attribute_type*/ 1) {
				attr(textarea, "placeholder", /*attribute_type*/ ctx[0]);
			}

			if (dirty & /*name*/ 2) {
				attr(textarea, "name", /*name*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(textarea);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$5(ctx) {
	let label;
	let span;
	let t0;
	let t1;
	let br;
	let t2;

	function select_block_type(ctx, dirty) {
		if (/*attribute_type*/ ctx[0] === "text" || /*attribute_type*/ ctx[0] === "upload" || /*attribute_type*/ ctx[0] === "array") return create_if_block$3;
		return create_else_block$3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			label = element("label");
			span = element("span");
			t0 = text(/*name*/ ctx[1]);
			t1 = space();
			br = element("br");
			t2 = space();
			if_block.c();
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true, for: true });
			var label_nodes = children(label);
			span = claim_element(label_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, /*name*/ ctx[1]);
			span_nodes.forEach(detach);
			t1 = claim_space(label_nodes);
			br = claim_element(label_nodes, "BR", {});
			t2 = claim_space(label_nodes);
			if_block.l(label_nodes);
			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "w-full");
			attr(label, "class", "block w-10/12");
			attr(label, "for", "attr_type");
		},
		m(target, anchor) {
			insert(target, label, anchor);
			append(label, span);
			append(span, t0);
			append(label, t1);
			append(label, br);
			append(label, t2);
			if_block.m(label, null);
		},
		p(ctx, [dirty]) {
			if (dirty & /*name*/ 2) set_data(t0, /*name*/ ctx[1]);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(label, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(label);
			if_block.d();
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { id } = $$props;
	let { attribute_type } = $$props;
	let { name } = $$props;
	let { value = "" } = $$props;

	// TODO: Rewrite to store?
	const propagateUpdate = e => {
		const data = {
			id,
			props: {
				[name]: {
					name,
					value: e.target.value,
					attribute_type
				}
			}
		};

		dispatch("formChanged", data);
	};

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(4, id = $$props.id);
		if ("attribute_type" in $$props) $$invalidate(0, attribute_type = $$props.attribute_type);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("value" in $$props) $$invalidate(2, value = $$props.value);
	};

	return [attribute_type, name, value, propagateUpdate, id];
}

class InputField extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			id: 4,
			attribute_type: 0,
			name: 1,
			value: 2
		});
	}
}

/* src/_components/NewModelInputField.svelte generated by Svelte v3.24.1 */

function create_fragment$4(ctx) {
	let label;
	let p;
	let t0;
	let t1;
	let span;
	let t2;
	let t3;
	let t4;
	let t5;
	let input;
	let input_placeholder_value;
	let mounted;
	let dispose;

	return {
		c() {
			label = element("label");
			p = element("p");
			t0 = text(/*name*/ ctx[1]);
			t1 = space();
			span = element("span");
			t2 = text("(");
			t3 = text(/*attribute_type*/ ctx[0]);
			t4 = text(")");
			t5 = space();
			input = element("input");
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			p = claim_element(label_nodes, "P", { class: true });
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, /*name*/ ctx[1]);
			t1 = claim_space(p_nodes);
			span = claim_element(p_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, "(");
			t3 = claim_text(span_nodes, /*attribute_type*/ ctx[0]);
			t4 = claim_text(span_nodes, ")");
			span_nodes.forEach(detach);
			p_nodes.forEach(detach);
			t5 = claim_space(label_nodes);

			input = claim_element(label_nodes, "INPUT", {
				class: true,
				type: true,
				value: true,
				placeholder: true
			});

			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "text-gray-600");
			attr(p, "class", "w-full mb-2");
			attr(input, "class", "w-10/12 mr-2 form-input");
			attr(input, "type", "text");
			input.value = /*value*/ ctx[2];
			attr(input, "placeholder", input_placeholder_value = /*getExample*/ ctx[4](/*attribute_type*/ ctx[0]));
			attr(label, "class", "block w-10/12");
		},
		m(target, anchor) {
			insert(target, label, anchor);
			append(label, p);
			append(p, t0);
			append(p, t1);
			append(p, span);
			append(span, t2);
			append(span, t3);
			append(span, t4);
			append(label, t5);
			append(label, input);

			if (!mounted) {
				dispose = listen(input, "input", /*input_handler*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*name*/ 2) set_data(t0, /*name*/ ctx[1]);
			if (dirty & /*attribute_type*/ 1) set_data(t3, /*attribute_type*/ ctx[0]);

			if (dirty & /*value*/ 4 && input.value !== /*value*/ ctx[2]) {
				input.value = /*value*/ ctx[2];
			}

			if (dirty & /*attribute_type*/ 1 && input_placeholder_value !== (input_placeholder_value = /*getExample*/ ctx[4](/*attribute_type*/ ctx[0]))) {
				attr(input, "placeholder", input_placeholder_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(label);
			mounted = false;
			dispose();
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { newProps } = $$props;
	let { attribute_type } = $$props;
	let { name } = $$props;
	let { value = "" } = $$props;

	function setProp({ name, value, attribute_type }) {
		$$invalidate(5, newProps[name] = { name, value, attribute_type }, newProps);
	}

	const getExample = type => {
		if (type === "string" || type === "text") return "\"my text\"";
		if (type === "integer") return "1337";
		if (type === "float") return "13.37";
		if (type === "array") return "[\"my\", \"array\", 10]";
		if (type === "boolean") return "true";
		if (type === "datetime") return "\"2019-04-03T00:00:00.000Z\"";
	};

	const input_handler = e => {
		setProp({
			name,
			value: e.target.value,
			attribute_type
		});
	};

	$$self.$$set = $$props => {
		if ("newProps" in $$props) $$invalidate(5, newProps = $$props.newProps);
		if ("attribute_type" in $$props) $$invalidate(0, attribute_type = $$props.attribute_type);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("value" in $$props) $$invalidate(2, value = $$props.value);
	};

	return [attribute_type, name, value, setProp, getExample, newProps, input_handler];
}

class NewModelInputField extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			newProps: 5,
			attribute_type: 0,
			name: 1,
			value: 2
		});
	}
}

/* src/pages/Models/Manage/_new.svelte generated by Svelte v3.24.1 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i].name;
	child_ctx[10] = list[i].attribute_type;
	child_ctx[12] = i;
	return child_ctx;
}

// (29:20) {:else}
function create_else_block$2(ctx) {
	let t;

	return {
		c() {
			t = text("+");
		},
		l(nodes) {
			t = claim_text(nodes, "+");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (29:2) {#if showNewForm}
function create_if_block_1$1(ctx) {
	let t;

	return {
		c() {
			t = text("-");
		},
		l(nodes) {
			t = claim_text(nodes, "-");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (32:0) {#if showNewForm}
function create_if_block$2(ctx) {
	let form;
	let t0;
	let br;
	let t1;
	let div;
	let button0;
	let t2;
	let t3;
	let button1;
	let t4;
	let form_intro;
	let form_outro;
	let current;
	let mounted;
	let dispose;
	let each_value = /*props*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			form = element("form");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			br = element("br");
			t1 = space();
			div = element("div");
			button0 = element("button");
			t2 = text("Create");
			t3 = space();
			button1 = element("button");
			t4 = text("Cancel");
			this.h();
		},
		l(nodes) {
			form = claim_element(nodes, "FORM", { class: true });
			var form_nodes = children(form);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(form_nodes);
			}

			t0 = claim_space(form_nodes);
			br = claim_element(form_nodes, "BR", {});
			t1 = claim_space(form_nodes);
			div = claim_element(form_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			button0 = claim_element(div_nodes, "BUTTON", { class: true });
			var button0_nodes = children(button0);
			t2 = claim_text(button0_nodes, "Create");
			button0_nodes.forEach(detach);
			t3 = claim_space(div_nodes);
			button1 = claim_element(div_nodes, "BUTTON", { type: true, class: true });
			var button1_nodes = children(button1);
			t4 = claim_text(button1_nodes, "Cancel");
			button1_nodes.forEach(detach);
			div_nodes.forEach(detach);
			form_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button0, "class", "button");
			attr(button1, "type", "button");
			attr(button1, "class", "ml-4 button link");
			attr(div, "class", "flex w-full mt-4");
			attr(form, "class", "flex flex-wrap p-6 mb-4 border border-blue-500 rounded");
		},
		m(target, anchor) {
			insert(target, form, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(form, null);
			}

			append(form, t0);
			append(form, br);
			append(form, t1);
			append(form, div);
			append(div, button0);
			append(button0, t2);
			append(div, t3);
			append(div, button1);
			append(button1, t4);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button1, "click", /*click_handler_1*/ ctx[8]),
					listen(form, "submit", prevent_default(/*handleSubmit*/ ctx[3]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*props, newProps*/ 5) {
				each_value = /*props*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(form, t0);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			add_render_callback(() => {
				if (form_outro) form_outro.end(1);
				if (!form_intro) form_intro = create_in_transition(form, slide, {});
				form_intro.start();
			});

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			if (form_intro) form_intro.invalidate();
			form_outro = create_out_transition(form, slide, {});
			current = false;
		},
		d(detaching) {
			if (detaching) detach(form);
			destroy_each(each_blocks, detaching);
			if (detaching && form_outro) form_outro.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (35:4) {#each props as { name, attribute_type }
function create_each_block$2(ctx) {
	let div;
	let newmodelinputfield;
	let updating_newProps;
	let current;

	function newmodelinputfield_newProps_binding(value) {
		/*newmodelinputfield_newProps_binding*/ ctx[7].call(null, value);
	}

	let newmodelinputfield_props = {
		attribute_type: /*attribute_type*/ ctx[10],
		name: /*name*/ ctx[9],
		value: "",
		placeholder: /*attribute_type*/ ctx[10]
	};

	if (/*newProps*/ ctx[2] !== void 0) {
		newmodelinputfield_props.newProps = /*newProps*/ ctx[2];
	}

	newmodelinputfield = new NewModelInputField({ props: newmodelinputfield_props });
	binding_callbacks.push(() => bind(newmodelinputfield, "newProps", newmodelinputfield_newProps_binding));

	return {
		c() {
			div = element("div");
			create_component(newmodelinputfield.$$.fragment);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(newmodelinputfield.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "w-5/12 mb-2 mr-4");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(newmodelinputfield, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const newmodelinputfield_changes = {};
			if (dirty & /*props*/ 1) newmodelinputfield_changes.attribute_type = /*attribute_type*/ ctx[10];
			if (dirty & /*props*/ 1) newmodelinputfield_changes.name = /*name*/ ctx[9];
			if (dirty & /*props*/ 1) newmodelinputfield_changes.placeholder = /*attribute_type*/ ctx[10];

			if (!updating_newProps && dirty & /*newProps*/ 4) {
				updating_newProps = true;
				newmodelinputfield_changes.newProps = /*newProps*/ ctx[2];
				add_flush_callback(() => updating_newProps = false);
			}

			newmodelinputfield.$set(newmodelinputfield_changes);
		},
		i(local) {
			if (current) return;
			transition_in(newmodelinputfield.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(newmodelinputfield.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(newmodelinputfield);
		}
	};
}

function create_fragment$3(ctx) {
	let button;
	let t0;
	let t1;
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*showNewForm*/ ctx[1]) return create_if_block_1$1;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*showNewForm*/ ctx[1] && create_if_block$2(ctx);

	return {
		c() {
			button = element("button");
			if_block0.c();
			t0 = text(" New record");
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			if_block0.l(button_nodes);
			t0 = claim_text(button_nodes, " New record");
			button_nodes.forEach(detach);
			t1 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},
		h() {
			attr(button, "class", "my-4 ml-auto button");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			if_block0.m(button, null);
			append(button, t0);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(button, t0);
				}
			}

			if (/*showNewForm*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*showNewForm*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if_block0.d();
			if (detaching) detach(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
			mounted = false;
			dispose();
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let showNewForm = false;
	let { schemaId } = $$props;
	let { schemaName } = $$props;
	let { props } = $$props;
	let newProps = {};

	const handleSubmit = () => {
		api.createModel(schemaName, newProps).then(data => {
			if (data) {
				modelsStore.refreshModels(schemaId);
				$$invalidate(1, showNewForm = false);
			}
		});
	};

	const click_handler = () => $$invalidate(1, showNewForm = !showNewForm);

	function newmodelinputfield_newProps_binding(value) {
		newProps = value;
		$$invalidate(2, newProps);
	}

	const click_handler_1 = () => $$invalidate(1, showNewForm = !showNewForm);

	$$self.$$set = $$props => {
		if ("schemaId" in $$props) $$invalidate(4, schemaId = $$props.schemaId);
		if ("schemaName" in $$props) $$invalidate(5, schemaName = $$props.schemaName);
		if ("props" in $$props) $$invalidate(0, props = $$props.props);
	};

	return [
		props,
		showNewForm,
		newProps,
		handleSubmit,
		schemaId,
		schemaName,
		click_handler,
		newmodelinputfield_newProps_binding,
		click_handler_1
	];
}

class New extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { schemaId: 4, schemaName: 5, props: 0 });
	}
}

/* src/pages/Models/Manage/_filter.svelte generated by Svelte v3.24.1 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	child_ctx[16] = i;
	return child_ctx;
}

// (52:18) {:else}
function create_else_block$1(ctx) {
	let t;

	return {
		c() {
			t = text("+");
		},
		l(nodes) {
			t = claim_text(nodes, "+");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (52:0) {#if showFilters}
function create_if_block_5(ctx) {
	let t;

	return {
		c() {
			t = text("-");
		},
		l(nodes) {
			t = claim_text(nodes, "-");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (55:0) {#if showFilters}
function create_if_block$1(ctx) {
	let form;
	let select0;
	let option0;
	let t0;
	let t1;
	let select1;
	let option1;
	let t2;
	let option2;
	let t3;
	let option3;
	let t4;
	let option4;
	let t5;
	let if_block0_anchor;
	let if_block1_anchor;
	let t6;
	let input;
	let input_value_value;
	let t7;
	let show_if = /*showValueField*/ ctx[6](/*selectedOperation*/ ctx[2], /*selectedProperty*/ ctx[3]);
	let t8;
	let br;
	let t9;
	let div;
	let button0;
	let t10;
	let t11;
	let button1;
	let t12;
	let form_intro;
	let form_outro;
	let current;
	let mounted;
	let dispose;
	let each_value = /*props*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	let if_block0 = (/*selectedProperty*/ ctx[3].attribute_type === "string" || /*selectedProperty*/ ctx[3].attribute_type === "text") && create_if_block_4();
	let if_block1 = (/*selectedProperty*/ ctx[3].attribute_type === "integer" || /*selectedProperty*/ ctx[3].attribute_type === "float") && create_if_block_3();
	let if_block2 = /*selectedProperty*/ ctx[3].attribute_type === "array" && create_if_block_2();
	let if_block3 = show_if && create_if_block_1(ctx);

	return {
		c() {
			form = element("form");
			select0 = element("select");
			option0 = element("option");
			t0 = text("Choose property");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			select1 = element("select");
			option1 = element("option");
			t2 = text("Choose filter type");
			option2 = element("option");
			t3 = text("contains");
			option3 = element("option");
			t4 = text("exists");
			option4 = element("option");
			t5 = text("not contains");
			if (if_block0) if_block0.c();
			if_block0_anchor = empty();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			if (if_block2) if_block2.c();
			t6 = space();
			input = element("input");
			t7 = space();
			if (if_block3) if_block3.c();
			t8 = space();
			br = element("br");
			t9 = space();
			div = element("div");
			button0 = element("button");
			t10 = text("Filter");
			t11 = space();
			button1 = element("button");
			t12 = text("Cancel");
			this.h();
		},
		l(nodes) {
			form = claim_element(nodes, "FORM", { class: true });
			var form_nodes = children(form);
			select0 = claim_element(form_nodes, "SELECT", { name: true, class: true, required: true });
			var select0_nodes = children(select0);
			option0 = claim_element(select0_nodes, "OPTION", { value: true, class: true });
			var option0_nodes = children(option0);
			t0 = claim_text(option0_nodes, "Choose property");
			option0_nodes.forEach(detach);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(select0_nodes);
			}

			select0_nodes.forEach(detach);
			t1 = claim_space(form_nodes);
			select1 = claim_element(form_nodes, "SELECT", { name: true, class: true, required: true });
			var select1_nodes = children(select1);
			option1 = claim_element(select1_nodes, "OPTION", { value: true, class: true });
			var option1_nodes = children(option1);
			t2 = claim_text(option1_nodes, "Choose filter type");
			option1_nodes.forEach(detach);
			option2 = claim_element(select1_nodes, "OPTION", { value: true });
			var option2_nodes = children(option2);
			t3 = claim_text(option2_nodes, "contains");
			option2_nodes.forEach(detach);
			option3 = claim_element(select1_nodes, "OPTION", { value: true });
			var option3_nodes = children(option3);
			t4 = claim_text(option3_nodes, "exists");
			option3_nodes.forEach(detach);
			option4 = claim_element(select1_nodes, "OPTION", { value: true });
			var option4_nodes = children(option4);
			t5 = claim_text(option4_nodes, "not contains");
			option4_nodes.forEach(detach);
			if (if_block0) if_block0.l(select1_nodes);
			if_block0_anchor = empty();
			if (if_block1) if_block1.l(select1_nodes);
			if_block1_anchor = empty();
			if (if_block2) if_block2.l(select1_nodes);
			select1_nodes.forEach(detach);
			t6 = claim_space(form_nodes);
			input = claim_element(form_nodes, "INPUT", { type: true, name: true, value: true });
			t7 = claim_space(form_nodes);
			if (if_block3) if_block3.l(form_nodes);
			t8 = claim_space(form_nodes);
			br = claim_element(form_nodes, "BR", {});
			t9 = claim_space(form_nodes);
			div = claim_element(form_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			button0 = claim_element(div_nodes, "BUTTON", { class: true });
			var button0_nodes = children(button0);
			t10 = claim_text(button0_nodes, "Filter");
			button0_nodes.forEach(detach);
			t11 = claim_space(div_nodes);
			button1 = claim_element(div_nodes, "BUTTON", { type: true, class: true });
			var button1_nodes = children(button1);
			t12 = claim_text(button1_nodes, "Cancel");
			button1_nodes.forEach(detach);
			div_nodes.forEach(detach);
			form_nodes.forEach(detach);
			this.h();
		},
		h() {
			option0.__value = "";
			option0.value = option0.__value;
			attr(option0, "class", "text-gray-500");
			attr(select0, "name", "property");
			attr(select0, "class", "mr-4 form-select");
			select0.required = true;
			if (/*selectedProperty*/ ctx[3] === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[10].call(select0));
			option1.__value = "";
			option1.value = option1.__value;
			attr(option1, "class", "text-gray-500");
			option2.__value = "contains";
			option2.value = option2.__value;
			option3.__value = "exists";
			option3.value = option3.__value;
			option4.__value = "not_contains";
			option4.value = option4.__value;
			attr(select1, "name", "operation");
			attr(select1, "class", "mr-2 form-select");
			select1.required = true;
			if (/*selectedOperation*/ ctx[2] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[12].call(select1));
			attr(input, "type", "hidden");
			attr(input, "name", "type");
			input.value = input_value_value = /*getPropType*/ ctx[5](/*props*/ ctx[0], /*selectedProperty*/ ctx[3]);
			attr(button0, "class", "button");
			attr(button1, "type", "button");
			attr(button1, "class", "ml-4 button link");
			attr(div, "class", "flex w-full mt-4");
			attr(form, "class", "flex flex-wrap items-center p-6 mb-4 border border-blue-500 rounded");
		},
		m(target, anchor) {
			insert(target, form, anchor);
			append(form, select0);
			append(select0, option0);
			append(option0, t0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select0, null);
			}

			select_option(select0, /*selectedProperty*/ ctx[3]);
			append(form, t1);
			append(form, select1);
			append(select1, option1);
			append(option1, t2);
			append(select1, option2);
			append(option2, t3);
			append(select1, option3);
			append(option3, t4);
			append(select1, option4);
			append(option4, t5);
			if (if_block0) if_block0.m(select1, null);
			append(select1, if_block0_anchor);
			if (if_block1) if_block1.m(select1, null);
			append(select1, if_block1_anchor);
			if (if_block2) if_block2.m(select1, null);
			select_option(select1, /*selectedOperation*/ ctx[2]);
			append(form, t6);
			append(form, input);
			append(form, t7);
			if (if_block3) if_block3.m(form, null);
			append(form, t8);
			append(form, br);
			append(form, t9);
			append(form, div);
			append(div, button0);
			append(button0, t10);
			append(div, t11);
			append(div, button1);
			append(button1, t12);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select0, "change", /*select0_change_handler*/ ctx[10]),
					listen(select0, "blur", /*blur_handler*/ ctx[11]),
					listen(select1, "change", /*select1_change_handler*/ ctx[12]),
					listen(button1, "click", /*click_handler_1*/ ctx[13]),
					listen(form, "submit", prevent_default(/*handleSubmit*/ ctx[4]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*props*/ 1) {
				each_value = /*props*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*selectedProperty, props*/ 9) {
				select_option(select0, /*selectedProperty*/ ctx[3]);
			}

			if (/*selectedProperty*/ ctx[3].attribute_type === "string" || /*selectedProperty*/ ctx[3].attribute_type === "text") {
				if (if_block0) ; else {
					if_block0 = create_if_block_4();
					if_block0.c();
					if_block0.m(select1, if_block0_anchor);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*selectedProperty*/ ctx[3].attribute_type === "integer" || /*selectedProperty*/ ctx[3].attribute_type === "float") {
				if (if_block1) ; else {
					if_block1 = create_if_block_3();
					if_block1.c();
					if_block1.m(select1, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*selectedProperty*/ ctx[3].attribute_type === "array") {
				if (if_block2) ; else {
					if_block2 = create_if_block_2();
					if_block2.c();
					if_block2.m(select1, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*selectedOperation*/ 4) {
				select_option(select1, /*selectedOperation*/ ctx[2]);
			}

			if (!current || dirty & /*props, selectedProperty*/ 9 && input_value_value !== (input_value_value = /*getPropType*/ ctx[5](/*props*/ ctx[0], /*selectedProperty*/ ctx[3]))) {
				input.value = input_value_value;
			}

			if (dirty & /*selectedOperation, selectedProperty*/ 12) show_if = /*showValueField*/ ctx[6](/*selectedOperation*/ ctx[2], /*selectedProperty*/ ctx[3]);

			if (show_if) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_1(ctx);
					if_block3.c();
					if_block3.m(form, t8);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (form_outro) form_outro.end(1);
				if (!form_intro) form_intro = create_in_transition(form, slide, {});
				form_intro.start();
			});

			current = true;
		},
		o(local) {
			if (form_intro) form_intro.invalidate();
			form_outro = create_out_transition(form, slide, {});
			current = false;
		},
		d(detaching) {
			if (detaching) detach(form);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (detaching && form_outro) form_outro.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (65:6) {#each props as prop, i}
function create_each_block$1(ctx) {
	let option;
	let t0_value = /*prop*/ ctx[14].name + "";
	let t0;
	let t1;
	let t2_value = /*prop*/ ctx[14].attribute_type + "";
	let t2;
	let t3;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t0 = text(t0_value);
			t1 = text(" (");
			t2 = text(t2_value);
			t3 = text(")");
			this.h();
		},
		l(nodes) {
			option = claim_element(nodes, "OPTION", { value: true });
			var option_nodes = children(option);
			t0 = claim_text(option_nodes, t0_value);
			t1 = claim_text(option_nodes, " (");
			t2 = claim_text(option_nodes, t2_value);
			t3 = claim_text(option_nodes, ")");
			option_nodes.forEach(detach);
			this.h();
		},
		h() {
			option.__value = option_value_value = /*prop*/ ctx[14].name;
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t0);
			append(option, t1);
			append(option, t2);
			append(option, t3);
		},
		p(ctx, dirty) {
			if (dirty & /*props*/ 1 && t0_value !== (t0_value = /*prop*/ ctx[14].name + "")) set_data(t0, t0_value);
			if (dirty & /*props*/ 1 && t2_value !== (t2_value = /*prop*/ ctx[14].attribute_type + "")) set_data(t2, t2_value);

			if (dirty & /*props*/ 1 && option_value_value !== (option_value_value = /*prop*/ ctx[14].name)) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (77:6) {#if selectedProperty.attribute_type === 'string' || selectedProperty.attribute_type === 'text'}
function create_if_block_4(ctx) {
	let option0;
	let t0;
	let option1;
	let t1;
	let option2;
	let t2;
	let option3;
	let t3;

	return {
		c() {
			option0 = element("option");
			t0 = text("ends with");
			option1 = element("option");
			t1 = text("starts with");
			option2 = element("option");
			t2 = text("not ends with");
			option3 = element("option");
			t3 = text("not starts with");
			this.h();
		},
		l(nodes) {
			option0 = claim_element(nodes, "OPTION", { value: true });
			var option0_nodes = children(option0);
			t0 = claim_text(option0_nodes, "ends with");
			option0_nodes.forEach(detach);
			option1 = claim_element(nodes, "OPTION", { value: true });
			var option1_nodes = children(option1);
			t1 = claim_text(option1_nodes, "starts with");
			option1_nodes.forEach(detach);
			option2 = claim_element(nodes, "OPTION", { value: true });
			var option2_nodes = children(option2);
			t2 = claim_text(option2_nodes, "not ends with");
			option2_nodes.forEach(detach);
			option3 = claim_element(nodes, "OPTION", { value: true });
			var option3_nodes = children(option3);
			t3 = claim_text(option3_nodes, "not starts with");
			option3_nodes.forEach(detach);
			this.h();
		},
		h() {
			option0.__value = "ends_with";
			option0.value = option0.__value;
			option1.__value = "starts_with";
			option1.value = option1.__value;
			option2.__value = "not_ends_with";
			option2.value = option2.__value;
			option3.__value = "not_starts_with";
			option3.value = option3.__value;
		},
		m(target, anchor) {
			insert(target, option0, anchor);
			append(option0, t0);
			insert(target, option1, anchor);
			append(option1, t1);
			insert(target, option2, anchor);
			append(option2, t2);
			insert(target, option3, anchor);
			append(option3, t3);
		},
		d(detaching) {
			if (detaching) detach(option0);
			if (detaching) detach(option1);
			if (detaching) detach(option2);
			if (detaching) detach(option3);
		}
	};
}

// (84:6) {#if selectedProperty.attribute_type === 'integer' || selectedProperty.attribute_type === 'float'}
function create_if_block_3(ctx) {
	let option;
	let t;

	return {
		c() {
			option = element("option");
			t = text("range");
			this.h();
		},
		l(nodes) {
			option = claim_element(nodes, "OPTION", { value: true });
			var option_nodes = children(option);
			t = claim_text(option_nodes, "range");
			option_nodes.forEach(detach);
			this.h();
		},
		h() {
			option.__value = "range";
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (88:6) {#if selectedProperty.attribute_type === 'array'}
function create_if_block_2(ctx) {
	let option0;
	let t0;
	let option1;
	let t1;

	return {
		c() {
			option0 = element("option");
			t0 = text("value in");
			option1 = element("option");
			t1 = text("not value in");
			this.h();
		},
		l(nodes) {
			option0 = claim_element(nodes, "OPTION", { value: true });
			var option0_nodes = children(option0);
			t0 = claim_text(option0_nodes, "value in");
			option0_nodes.forEach(detach);
			option1 = claim_element(nodes, "OPTION", { value: true });
			var option1_nodes = children(option1);
			t1 = claim_text(option1_nodes, "not value in");
			option1_nodes.forEach(detach);
			this.h();
		},
		h() {
			option0.__value = "value_in";
			option0.value = option0.__value;
			option1.__value = "not_value_in";
			option1.value = option1.__value;
		},
		m(target, anchor) {
			insert(target, option0, anchor);
			append(option0, t0);
			insert(target, option1, anchor);
			append(option1, t1);
		},
		d(detaching) {
			if (detaching) detach(option0);
			if (detaching) detach(option1);
		}
	};
}

// (96:4) {#if showValueField(selectedOperation, selectedProperty)}
function create_if_block_1(ctx) {
	let input;
	let t0;
	let p;
	let t1;
	let t2_value = /*getHint*/ ctx[7](/*selectedOperation*/ ctx[2]) + "";
	let t2;

	return {
		c() {
			input = element("input");
			t0 = space();
			p = element("p");
			t1 = text("Example: ");
			t2 = text(t2_value);
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, name: true, class: true });
			t0 = claim_space(nodes);
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t1 = claim_text(p_nodes, "Example: ");
			t2 = claim_text(p_nodes, t2_value);
			p_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(input, "type", "text");
			attr(input, "name", "value");
			attr(input, "class", "w-64 form-input");
			attr(p, "class", "ml-4 text-gray-600");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			insert(target, t0, anchor);
			insert(target, p, anchor);
			append(p, t1);
			append(p, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*selectedOperation*/ 4 && t2_value !== (t2_value = /*getHint*/ ctx[7](/*selectedOperation*/ ctx[2]) + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(input);
			if (detaching) detach(t0);
			if (detaching) detach(p);
		}
	};
}

function create_fragment$2(ctx) {
	let button;
	let t0;
	let t1;
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*showFilters*/ ctx[1]) return create_if_block_5;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*showFilters*/ ctx[1] && create_if_block$1(ctx);

	return {
		c() {
			button = element("button");
			if_block0.c();
			t0 = text(" Filter");
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			if_block0.l(button_nodes);
			t0 = claim_text(button_nodes, " Filter");
			button_nodes.forEach(detach);
			t1 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},
		h() {
			attr(button, "class", "my-4 ml-auto button");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			if_block0.m(button, null);
			append(button, t0);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[9]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(button, t0);
				}
			}

			if (/*showFilters*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*showFilters*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if_block0.d();
			if (detaching) detach(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
			mounted = false;
			dispose();
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { props } = $$props;
	let { schemaId } = $$props;
	let showFilters = false;
	let selectedOperation = "";
	let selectedProperty = "";

	const handleSubmit = evt => {
		const form = evt.target;
		const fd = new FormData(form);
		const filters = Object.fromEntries(fd);
		filtersStore.set(filters);
		modelsStore.refreshModels(schemaId);
	};

	const getPropType = (props, name) => {
		const prop = props.find(prop => prop.name === name);

		if (prop) {
			return prop.attribute_type;
		}
	};

	const showValueField = (op, { attribute_type: type }) => {
		if (op === "value-in" || op === "value-not-in") {
			if (type === "array") return true;
			return false;
		}

		return true;
	};

	const getHint = op => {
		if (op === "range") return "{ gt: \"10\", lt: \"20\" } - remember about JSON format and double quotes";
		if (op === "value_in" || op === "not_value_in") return "[10, \"platformOS\", 30] - remember about square brackets and double quotes";
		if (op === "ends_with" || op === "not-ends-with") return "\"platformOS\" - remember about double quotes";
		if (op === "starts_with" || op === "not-starts-with") return "\"platformOS\" - remember about double quotes";
		if (op === "exists" || op === "not-starts-with") return "true - booleans are NOT inside quotes";
		return "\"platformOS\" - remember about double quotes";
	};

	const click_handler = () => $$invalidate(1, showFilters = !showFilters);

	function select0_change_handler() {
		selectedProperty = select_value(this);
		$$invalidate(3, selectedProperty);
		$$invalidate(0, props);
	}

	const blur_handler = () => $$invalidate(2, selectedOperation = undefined);

	function select1_change_handler() {
		selectedOperation = select_value(this);
		$$invalidate(2, selectedOperation);
	}

	const click_handler_1 = () => {
		filtersStore.reset();
		$$invalidate(1, showFilters = false);
	};

	$$self.$$set = $$props => {
		if ("props" in $$props) $$invalidate(0, props = $$props.props);
		if ("schemaId" in $$props) $$invalidate(8, schemaId = $$props.schemaId);
	};

	return [
		props,
		showFilters,
		selectedOperation,
		selectedProperty,
		handleSubmit,
		getPropType,
		showValueField,
		getHint,
		schemaId,
		click_handler,
		select0_change_handler,
		blur_handler,
		select1_change_handler,
		click_handler_1
	];
}

class Filter extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { props: 0, schemaId: 8 });
	}
}

/* src/pages/Models/Manage/_pagination.svelte generated by Svelte v3.24.1 */

function create_fragment$1(ctx) {
	let ul;
	let li0;
	let button0;
	let t0;
	let t1;
	let li1;
	let t2;
	let t3_value = /*$pageStore*/ ctx[0].total_pages + "";
	let t3;
	let t4;
	let li2;
	let t5;
	let t6_value = /*$pageStore*/ ctx[0].page + "";
	let t6;
	let t7;
	let li3;
	let button1;
	let t8;
	let mounted;
	let dispose;

	return {
		c() {
			ul = element("ul");
			li0 = element("li");
			button0 = element("button");
			t0 = text("Previous page");
			t1 = space();
			li1 = element("li");
			t2 = text("Total Pages: ");
			t3 = text(t3_value);
			t4 = space();
			li2 = element("li");
			t5 = text("Current page: ");
			t6 = text(t6_value);
			t7 = space();
			li3 = element("li");
			button1 = element("button");
			t8 = text("Next page");
			this.h();
		},
		l(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", {});
			var li0_nodes = children(li0);
			button0 = claim_element(li0_nodes, "BUTTON", { class: true });
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "Previous page");
			button0_nodes.forEach(detach);
			li0_nodes.forEach(detach);
			t1 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", {});
			var li1_nodes = children(li1);
			t2 = claim_text(li1_nodes, "Total Pages: ");
			t3 = claim_text(li1_nodes, t3_value);
			li1_nodes.forEach(detach);
			t4 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", {});
			var li2_nodes = children(li2);
			t5 = claim_text(li2_nodes, "Current page: ");
			t6 = claim_text(li2_nodes, t6_value);
			li2_nodes.forEach(detach);
			t7 = claim_space(ul_nodes);
			li3 = claim_element(ul_nodes, "LI", {});
			var li3_nodes = children(li3);
			button1 = claim_element(li3_nodes, "BUTTON", { class: true });
			var button1_nodes = children(button1);
			t8 = claim_text(button1_nodes, "Next page");
			button1_nodes.forEach(detach);
			li3_nodes.forEach(detach);
			ul_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button0, "class", "button secondary");
			attr(button1, "class", "button secondary");
			attr(ul, "class", "flex justify-between");
		},
		m(target, anchor) {
			insert(target, ul, anchor);
			append(ul, li0);
			append(li0, button0);
			append(button0, t0);
			append(ul, t1);
			append(ul, li1);
			append(li1, t2);
			append(li1, t3);
			append(ul, t4);
			append(ul, li2);
			append(li2, t5);
			append(li2, t6);
			append(ul, t7);
			append(ul, li3);
			append(li3, button1);
			append(button1, t8);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*decrementPage*/ ctx[2]),
					listen(button1, "click", /*incrementPage*/ ctx[1])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*$pageStore*/ 1 && t3_value !== (t3_value = /*$pageStore*/ ctx[0].total_pages + "")) set_data(t3, t3_value);
			if (dirty & /*$pageStore*/ 1 && t6_value !== (t6_value = /*$pageStore*/ ctx[0].page + "")) set_data(t6, t6_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(ul);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let $pageStore;
	component_subscribe($$self, pageStore, $$value => $$invalidate(0, $pageStore = $$value));

	const incrementPage = () => {
		pageStore.increment();
		const ps = get_store_value(pageStore);
		modelsStore.refreshModels(ps.schemaId, ps.page);
	};

	const decrementPage = () => {
		pageStore.decrement();
		const ps = get_store_value(pageStore);
		modelsStore.refreshModels(ps.schemaId, ps.page);
	};

	return [$pageStore, incrementPage, decrementPage];
}

class Pagination extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
	}
}

/* src/pages/Models/Manage/[id].svelte generated by Svelte v3.24.1 */

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[24] = list[i].name;
	child_ctx[25] = list[i].attribute_type;
	child_ctx[23] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i].id;
	child_ctx[18] = list[i].created_at;
	child_ctx[19] = list[i].updated_at;
	child_ctx[20] = list[i].deleted_at;
	child_ctx[21] = list[i].properties;
	child_ctx[23] = i;
	return child_ctx;
}

// (114:12) {#each props as { name, attribute_type }
function create_each_block_1(ctx) {
	let div;
	let inputfield;
	let current;

	inputfield = new InputField({
			props: {
				attribute_type: /*attribute_type*/ ctx[25],
				name: /*name*/ ctx[24],
				id: /*id*/ ctx[17],
				value: /*properties*/ ctx[21][/*name*/ ctx[24]]
			}
		});

	inputfield.$on("formChanged", /*handleFormChanged*/ ctx[6]);

	return {
		c() {
			div = element("div");
			create_component(inputfield.$$.fragment);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(inputfield.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "w-5/12 mb-3 mr-4");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(inputfield, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const inputfield_changes = {};
			if (dirty & /*props*/ 8) inputfield_changes.attribute_type = /*attribute_type*/ ctx[25];
			if (dirty & /*props*/ 8) inputfield_changes.name = /*name*/ ctx[24];
			if (dirty & /*data*/ 4) inputfield_changes.id = /*id*/ ctx[17];
			if (dirty & /*data, props*/ 12) inputfield_changes.value = /*properties*/ ctx[21][/*name*/ ctx[24]];
			inputfield.$set(inputfield_changes);
		},
		i(local) {
			if (current) return;
			transition_in(inputfield.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(inputfield.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(inputfield);
		}
	};
}

// (135:12) {:else}
function create_else_block(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[13](/*id*/ ctx[17], ...args);
	}

	return {
		c() {
			button = element("button");
			t = text("Delete");
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true, type: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Delete");
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "class", "ml-auto button danger");
			attr(button, "type", "button");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_3);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (128:12) {#if deleted_at}
function create_if_block(ctx) {
	let div;
	let p;
	let t0;
	let br;
	let t1;
	let t2_value = getTime(/*deleted_at*/ ctx[20]) + "";
	let t2;
	let t3;
	let button;
	let t4;
	let mounted;
	let dispose;

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[12](/*id*/ ctx[17], ...args);
	}

	return {
		c() {
			div = element("div");
			p = element("p");
			t0 = text("This record was deleted at: ");
			br = element("br");
			t1 = space();
			t2 = text(t2_value);
			t3 = space();
			button = element("button");
			t4 = text("Restore record");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			p = claim_element(div_nodes, "P", { class: true });
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "This record was deleted at: ");
			br = claim_element(p_nodes, "BR", {});
			t1 = claim_space(p_nodes);
			t2 = claim_text(p_nodes, t2_value);
			p_nodes.forEach(detach);
			t3 = claim_space(div_nodes);
			button = claim_element(div_nodes, "BUTTON", { class: true, type: true });
			var button_nodes = children(button);
			t4 = claim_text(button_nodes, "Restore record");
			button_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(p, "class", "mb-2");
			attr(button, "class", "button secondary");
			attr(button, "type", "button");
			attr(div, "class", "w-64 ml-auto");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, p);
			append(p, t0);
			append(p, br);
			append(p, t1);
			append(p, t2);
			append(div, t3);
			append(div, button);
			append(button, t4);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_2);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*data*/ 4 && t2_value !== (t2_value = getTime(/*deleted_at*/ ctx[20]) + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (98:2) {#each data as { id, created_at, updated_at, deleted_at, properties }
function create_each_block(key_1, ctx) {
	let article;
	let div2;
	let div1;
	let header;
	let h3;
	let t0;
	let t1_value = /*id*/ ctx[17] + "";
	let t1;
	let t2;
	let p;
	let t3;
	let t4_value = getTime(/*created_at*/ ctx[18]) + "";
	let t4;
	let t5;
	let br;
	let t6;
	let t7_value = getTime(/*updated_at*/ ctx[19]) + "";
	let t7;
	let t8;
	let form;
	let t9;
	let div0;
	let button;
	let t10;
	let t11;
	let footer;
	let t12;
	let article_transition;
	let current;
	let mounted;
	let dispose;
	let each_value_1 = /*props*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	function submit_handler(...args) {
		return /*submit_handler*/ ctx[11](/*id*/ ctx[17], ...args);
	}

	function select_block_type(ctx, dirty) {
		if (/*deleted_at*/ ctx[20]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		key: key_1,
		first: null,
		c() {
			article = element("article");
			div2 = element("div");
			div1 = element("div");
			header = element("header");
			h3 = element("h3");
			t0 = text("ID: ");
			t1 = text(t1_value);
			t2 = space();
			p = element("p");
			t3 = text("Created: ");
			t4 = text(t4_value);
			t5 = space();
			br = element("br");
			t6 = text("\n              Updated: ");
			t7 = text(t7_value);
			t8 = space();
			form = element("form");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t9 = space();
			div0 = element("div");
			button = element("button");
			t10 = text("Save");
			t11 = space();
			footer = element("footer");
			if_block.c();
			t12 = space();
			this.h();
		},
		l(nodes) {
			article = claim_element(nodes, "ARTICLE", { class: true });
			var article_nodes = children(article);
			div2 = claim_element(article_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			header = claim_element(div1_nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			h3 = claim_element(header_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "ID: ");
			t1 = claim_text(h3_nodes, t1_value);
			h3_nodes.forEach(detach);
			t2 = claim_space(header_nodes);
			p = claim_element(header_nodes, "P", { class: true });
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, "Created: ");
			t4 = claim_text(p_nodes, t4_value);
			t5 = claim_space(p_nodes);
			br = claim_element(p_nodes, "BR", {});
			t6 = claim_text(p_nodes, "\n              Updated: ");
			t7 = claim_text(p_nodes, t7_value);
			p_nodes.forEach(detach);
			header_nodes.forEach(detach);
			t8 = claim_space(div1_nodes);
			form = claim_element(div1_nodes, "FORM", { class: true });
			var form_nodes = children(form);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(form_nodes);
			}

			t9 = claim_space(form_nodes);
			div0 = claim_element(form_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			button = claim_element(div0_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t10 = claim_text(button_nodes, "Save");
			button_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			form_nodes.forEach(detach);
			t11 = claim_space(div1_nodes);
			footer = claim_element(div1_nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			if_block.l(footer_nodes);
			footer_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t12 = claim_space(article_nodes);
			article_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h3, "class", "text-3xl font-light");
			attr(p, "class", "ml-auto");
			attr(header, "class", "flex pb-6 mb-6 border-b border-blue-600");
			attr(button, "class", "button");
			attr(div0, "class", "w-full mt-4");
			attr(form, "class", "flex flex-wrap");
			attr(footer, "class", "flex");
			attr(div1, "class", "h-full p-8 bg-gray-200 rounded");
			toggle_class(div1, "bg-red-200", /*deleted_at*/ ctx[20]);
			attr(div2, "class", "w-full");
			attr(article, "class", "flex flex-wrap w-full mb-6");
			this.first = article;
		},
		m(target, anchor) {
			insert(target, article, anchor);
			append(article, div2);
			append(div2, div1);
			append(div1, header);
			append(header, h3);
			append(h3, t0);
			append(h3, t1);
			append(header, t2);
			append(header, p);
			append(p, t3);
			append(p, t4);
			append(p, t5);
			append(p, br);
			append(p, t6);
			append(p, t7);
			append(div1, t8);
			append(div1, form);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(form, null);
			}

			append(form, t9);
			append(form, div0);
			append(div0, button);
			append(button, t10);
			append(div1, t11);
			append(div1, footer);
			if_block.m(footer, null);
			append(article, t12);
			current = true;

			if (!mounted) {
				dispose = listen(form, "submit", prevent_default(submit_handler));
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*data*/ 4) && t1_value !== (t1_value = /*id*/ ctx[17] + "")) set_data(t1, t1_value);
			if ((!current || dirty & /*data*/ 4) && t4_value !== (t4_value = getTime(/*created_at*/ ctx[18]) + "")) set_data(t4, t4_value);
			if ((!current || dirty & /*data*/ 4) && t7_value !== (t7_value = getTime(/*updated_at*/ ctx[19]) + "")) set_data(t7, t7_value);

			if (dirty & /*props, data, handleFormChanged*/ 76) {
				each_value_1 = /*props*/ ctx[3];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(form, t9);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(footer, null);
				}
			}

			if (dirty & /*data*/ 4) {
				toggle_class(div1, "bg-red-200", /*deleted_at*/ ctx[20]);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			add_render_callback(() => {
				if (!article_transition) article_transition = create_bidirectional_transition(article, slide, {}, true);
				article_transition.run(1);
			});

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			if (!article_transition) article_transition = create_bidirectional_transition(article, slide, {}, false);
			article_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(article);
			destroy_each(each_blocks, detaching);
			if_block.d();
			if (detaching && article_transition) article_transition.end();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let div4;
	let div0;
	let h1;
	let t0;
	let t1;
	let div1;
	let newmodel;
	let t2;
	let div2;
	let filter;
	let t3;
	let div3;
	let button0;
	let t4;
	let t5;
	let button1;
	let t6;
	let t7;
	let section;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t8;
	let pagination;
	let current;
	let mounted;
	let dispose;

	newmodel = new New({
			props: {
				props: /*props*/ ctx[3],
				schemaName: /*schemaName*/ ctx[0]
			}
		});

	filter = new Filter({
			props: {
				props: /*props*/ ctx[3],
				schemaId: /*schemaId*/ ctx[4]
			}
		});

	let each_value = /*data*/ ctx[2];
	const get_key = ctx => /*id*/ ctx[17];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	pagination = new Pagination({});

	return {
		c() {
			div4 = element("div");
			div0 = element("div");
			h1 = element("h1");
			t0 = text(/*schemaName*/ ctx[0]);
			t1 = space();
			div1 = element("div");
			create_component(newmodel.$$.fragment);
			t2 = space();
			div2 = element("div");
			create_component(filter.$$.fragment);
			t3 = space();
			div3 = element("div");
			button0 = element("button");
			t4 = text("Show non-deleted");
			t5 = space();
			button1 = element("button");
			t6 = text("Show deleted");
			t7 = space();
			section = element("section");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t8 = space();
			create_component(pagination.$$.fragment);
			this.h();
		},
		l(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			h1 = claim_element(div0_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, /*schemaName*/ ctx[0]);
			h1_nodes.forEach(detach);
			div0_nodes.forEach(detach);
			t1 = claim_space(div4_nodes);
			div1 = claim_element(div4_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(newmodel.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach);
			t2 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			claim_component(filter.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach);
			t3 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			button0 = claim_element(div3_nodes, "BUTTON", { type: true, class: true });
			var button0_nodes = children(button0);
			t4 = claim_text(button0_nodes, "Show non-deleted");
			button0_nodes.forEach(detach);
			t5 = claim_space(div3_nodes);
			button1 = claim_element(div3_nodes, "BUTTON", { type: true, class: true });
			var button1_nodes = children(button1);
			t6 = claim_text(button1_nodes, "Show deleted");
			button1_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			div4_nodes.forEach(detach);
			t7 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(section_nodes);
			}

			section_nodes.forEach(detach);
			t8 = claim_space(nodes);
			claim_component(pagination.$$.fragment, nodes);
			this.h();
		},
		h() {
			attr(h1, "class", "text-4xl");
			attr(div0, "class", "w-1/2");
			attr(div1, "class", "w-full");
			attr(div2, "class", "w-full");
			attr(button0, "type", "button");
			attr(button0, "class", "mr-4 button secondary");
			toggle_class(button0, "active", /*show*/ ctx[1] === "nondeleted");
			attr(button1, "type", "button");
			attr(button1, "class", "button secondary");
			toggle_class(button1, "active", /*show*/ ctx[1] === "deleted");
			attr(div3, "class", "flex w-full");
			attr(div4, "class", "flex flex-wrap mb-6");
			attr(section, "class", "flex flex-wrap text-gray-700 ");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div0);
			append(div0, h1);
			append(h1, t0);
			append(div4, t1);
			append(div4, div1);
			mount_component(newmodel, div1, null);
			append(div4, t2);
			append(div4, div2);
			mount_component(filter, div2, null);
			append(div4, t3);
			append(div4, div3);
			append(div3, button0);
			append(button0, t4);
			append(div3, t5);
			append(div3, button1);
			append(button1, t6);
			insert(target, t7, anchor);
			insert(target, section, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(section, null);
			}

			insert(target, t8, anchor);
			mount_component(pagination, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler*/ ctx[9]),
					listen(button1, "click", /*click_handler_1*/ ctx[10])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*schemaName*/ 1) set_data(t0, /*schemaName*/ ctx[0]);
			const newmodel_changes = {};
			if (dirty & /*props*/ 8) newmodel_changes.props = /*props*/ ctx[3];
			if (dirty & /*schemaName*/ 1) newmodel_changes.schemaName = /*schemaName*/ ctx[0];
			newmodel.$set(newmodel_changes);
			const filter_changes = {};
			if (dirty & /*props*/ 8) filter_changes.props = /*props*/ ctx[3];
			filter.$set(filter_changes);

			if (dirty & /*show*/ 2) {
				toggle_class(button0, "active", /*show*/ ctx[1] === "nondeleted");
			}

			if (dirty & /*show*/ 2) {
				toggle_class(button1, "active", /*show*/ ctx[1] === "deleted");
			}

			if (dirty & /*data, handleUndelete, getTime, handleDelete, handleUpdateModel, props, handleFormChanged*/ 492) {
				const each_value = /*data*/ ctx[2];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, section, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(newmodel.$$.fragment, local);
			transition_in(filter.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(pagination.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(newmodel.$$.fragment, local);
			transition_out(filter.$$.fragment, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(pagination.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			destroy_component(newmodel);
			destroy_component(filter);
			if (detaching) detach(t7);
			if (detaching) detach(section);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t8);
			destroy_component(pagination, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $params;
	let $modelsStore;
	component_subscribe($$self, params, $$value => $$invalidate(15, $params = $$value));
	component_subscribe($$self, modelsStore, $$value => $$invalidate(16, $modelsStore = $$value));
	const schemaId = $params.id;
	let schemaName;
	let show = "nondeleted";
	let data = [];
	let props = [];

	onMount(() => {
		pageStore.setSchemaId(schemaId);
		modelsStore.refreshModels(schemaId);

		api.getModelSchemas(schemaId).then(schema => {
			$$invalidate(0, schemaName = schema[0].name);
			$$invalidate(3, props = schema[0].properties);
		});
	});

	const handleDelete = id => {
		const confirmation = confirm("Are you sure you want to delete this record?");
		if (!confirmation) return;

		api.deleteModel(id).then(data => {
			modelsStore.refreshModels(schemaId);
		});
	};

	const formCache = {};

	const handleFormChanged = ({ detail }) => {
		// FIXME: MONSTER - Maybe use store for that?
		const currentData = formCache[detail.id] || {};

		const model = Object.assign({}, currentData, detail.props);
		formCache[detail.id] = model;
	};

	const handleUpdateModel = ({ id }) => {
		api.updateModel({ id, props: formCache[id] }).then(data => {
			
		});
	};

	const handleUndelete = id => {
		api.undeleteModel(id).then(data => {
			modelsStore.refreshModels(schemaId);
		});
	};

	const click_handler = () => $$invalidate(1, show = "nondeleted");
	const click_handler_1 = () => $$invalidate(1, show = "deleted");
	const submit_handler = (id, e) => handleUpdateModel({ id });
	const click_handler_2 = id => handleUndelete(id);
	const click_handler_3 = id => handleDelete(id);

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*show, $modelsStore*/ 65538) {
			if (show === "nondeleted") {
				$$invalidate(2, data = $modelsStore.filter(m => !m.deleted_at));
			} else {
				$$invalidate(2, data = $modelsStore.filter(m => m.deleted_at));
			}
		}
	};

	return [
		schemaName,
		show,
		data,
		props,
		schemaId,
		handleDelete,
		handleFormChanged,
		handleUpdateModel,
		handleUndelete,
		click_handler,
		click_handler_1,
		submit_handler,
		click_handler_2,
		click_handler_3
	];
}

class U5Bidu5D extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default U5Bidu5D;
