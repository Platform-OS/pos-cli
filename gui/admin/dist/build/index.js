import { S as SvelteComponent, i as init, s as safe_not_equal, J as empty, D as create_component, E as claim_component, k as insert, F as mount_component, z as transition_in, A as transition_out, g as detach, H as destroy_component, e as element, b as space, c as claim_element, d as children, h as claim_space, j as attr, a as append, w as update_keyed_each, y as check_outros, l as component_subscribe, v as group_outros, x as outro_and_destroy_block } from './main2.js';
import { f as fetchConstants } from './fetchConstants.js';
import Item from './Item.js';
import NewItem from './NewItem.js';
import Details from './Details.js';
import { c as constants } from './store2.js';
import './api.js';
import './store.js';

/* src/pages/Constants/index.svelte generated by Svelte v3.24.1 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (12:2) {#each $constants as item (item.name)}
function create_each_block(key_1, ctx) {
	let first;
	let item;
	let current;
	item = new Item({ props: { item: /*item*/ ctx[1] } });

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(item.$$.fragment);
			this.h();
		},
		l(nodes) {
			first = empty();
			claim_component(item.$$.fragment, nodes);
			this.h();
		},
		h() {
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(item, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const item_changes = {};
			if (dirty & /*$constants*/ 1) item_changes.item = /*item*/ ctx[1];
			item.$set(item_changes);
		},
		i(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(item, detaching);
		}
	};
}

function create_fragment(ctx) {
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t0;
	let newitem;
	let t1;
	let details;
	let current;
	let each_value = /*$constants*/ ctx[0];
	const get_key = ctx => /*item*/ ctx[1].name;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	newitem = new NewItem({});
	details = new Details({});

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			create_component(newitem.$$.fragment);
			t1 = space();
			create_component(details.$$.fragment);
			this.h();
		},
		l(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			t0 = claim_space(ul_nodes);
			claim_component(newitem.$$.fragment, ul_nodes);
			t1 = claim_space(ul_nodes);
			claim_component(details.$$.fragment, ul_nodes);
			ul_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(ul, "class", "pb-4");
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append(ul, t0);
			mount_component(newitem, ul, null);
			append(ul, t1);
			mount_component(details, ul, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*$constants*/ 1) {
				const each_value = /*$constants*/ ctx[0];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block, t0, get_each_context);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(newitem.$$.fragment, local);
			transition_in(details.$$.fragment, local);
			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(newitem.$$.fragment, local);
			transition_out(details.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			destroy_component(newitem);
			destroy_component(details);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $constants;
	component_subscribe($$self, constants, $$value => $$invalidate(0, $constants = $$value));
	fetchConstants();
	return [$constants];
}

class Constants extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Constants;
